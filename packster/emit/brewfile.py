"""Brewfile generation for Packster."""

import logging
from pathlib import Path
from typing import List, Dict, Set
from ..types import MappingResult, Decision
from ..config import DEFAULT_BREW_TAPS

logger = logging.getLogger(__name__)


def write_brewfile(
    mapping_results: List[MappingResult],
    output_dir: Path,
    include_taps: bool = True
) -> None:
    """Write a Brewfile with Homebrew packages and casks.
    
    Args:
        mapping_results: List of mapping results
        output_path: Path to write the Brewfile
        include_taps: Whether to include default taps
    """
    # Collect packages by type
    brew_packages = set()
    cask_packages = set()
    taps = set()
    
    # Add default taps
    if include_taps:
        taps.update(DEFAULT_BREW_TAPS)
    
    # Process mapping results
    for result in mapping_results:
        # Only include auto and verify decisions
        if result.decision not in [Decision.AUTO, Decision.VERIFY]:
            continue
        
        # Support new shape (single candidate field)
        best_candidate = getattr(result, "candidate", None)
        if best_candidate is None and hasattr(result, "candidates") and result.candidates:
            best_candidate = max(result.candidates, key=lambda c: c.confidence)
        if best_candidate is None:
            continue
        
        # Add to appropriate collection
        pm = getattr(best_candidate, "target_pm", getattr(best_candidate, "pm", ""))
        name = getattr(best_candidate, "target_name", getattr(best_candidate, "name", ""))
        if pm == "brew":
            brew_packages.add(name)
        elif pm == "cask":
            cask_packages.add(name)
        elif pm.startswith("tap:"):
            # Handle custom taps
            tap_name = pm[4:]  # Remove "tap:" prefix
            taps.add(tap_name)
    
    # Ensure directory exists and build file path
    output_dir.mkdir(parents=True, exist_ok=True)
    output_path = output_dir / "Brewfile"

    # Write Brewfile (tests expect single quotes)
    with open(output_path, 'w', encoding='utf-8') as f:
        # Write header
        f.write("# Brewfile generated by Packster\n")
        f.write("# Cross-OS package migration helper\n\n")
        
        # Write taps
        if taps:
            f.write("# Taps\n")
            for tap in sorted(taps):
                f.write(f"tap '{tap}'\n")
            f.write("\n")
        
        # Write brew packages
        if brew_packages:
            f.write("# Homebrew packages\n")
            for package in sorted(brew_packages):
                f.write(f"brew '{package}'\n")
            f.write("\n")
        
        # Write cask packages
        if cask_packages:
            f.write("# Homebrew casks\n")
            for package in sorted(cask_packages):
                f.write(f"cask '{package}'\n")
            f.write("\n")
        
        # Write footer
        f.write("# End of Brewfile\n")
    
    logger.info(f"Wrote Brewfile with {len(brew_packages)} brew packages and {len(cask_packages)} casks")


def get_brewfile_statistics(mapping_results: List[MappingResult]) -> Dict[str, int]:
    """Get statistics about what would be written to the Brewfile.
    
    Args:
        mapping_results: List of mapping results
        
    Returns:
        Dictionary with package counts
    """
    stats = {
        "brew_packages": 0,
        "cask_packages": 0,
        "taps": 0,
        "auto_packages": 0,
        "verify_packages": 0,
    }
    
    for result in mapping_results:
        if result.decision not in [Decision.AUTO, Decision.VERIFY]:
            continue
        
        if not result.candidates:
            continue
        
        best_candidate = max(result.candidates, key=lambda c: c.confidence)
        
        if best_candidate.pm == "brew":
            stats["brew_packages"] += 1
        elif best_candidate.pm == "cask":
            stats["cask_packages"] += 1
        elif best_candidate.pm.startswith("tap:"):
            stats["taps"] += 1
        
        if result.decision == Decision.AUTO:
            stats["auto_packages"] += 1
        elif result.decision == Decision.VERIFY:
            stats["verify_packages"] += 1
    
    return stats


def validate_brewfile(brewfile_path: Path) -> bool:
    """Validate a generated Brewfile.
    
    Args:
        brewfile_path: Path to the Brewfile
        
    Returns:
        True if Brewfile is valid, False otherwise
    """
    try:
        with open(brewfile_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Basic validation
        lines = content.splitlines()
        
        for line in lines:
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            
            # Check for valid brewfile syntax
            if line.startswith('tap '):
                if not line.count('"') == 2:
                    return False
            elif line.startswith('brew '):
                if not line.count('"') == 2:
                    return False
            elif line.startswith('cask '):
                if not line.count('"') == 2:
                    return False
            else:
                # Unknown line format
                return False
        
        return True
        
    except Exception as e:
        logger.error(f"Error validating Brewfile {brewfile_path}: {e}")
        return False


def format_brewfile_entry(package_type: str, package_name: str, **kwargs) -> str:
    """Format a single Brewfile entry.
    
    Args:
        package_type: Type of entry (tap, brew, cask)
        package_name: Name of the package
        **kwargs: Additional formatting options
        
    Returns:
        Formatted Brewfile line
    """
    if package_type == "tap":
        return f'tap "{package_name}"'
    elif package_type == "brew":
        return f'brew "{package_name}"'
    elif package_type == "cask":
        return f'cask "{package_name}"'
    else:
        raise ValueError(f"Unknown package type: {package_type}")


def parse_brewfile(brewfile_path: Path) -> Dict[str, List[str]]:
    """Parse an existing Brewfile.
    
    Args:
        brewfile_path: Path to the Brewfile
        
    Returns:
        Dictionary with 'taps', 'brew', and 'cask' lists
    """
    result = {
        "taps": [],
        "brew": [],
        "cask": []
    }
    
    try:
        with open(brewfile_path, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith('#'):
                    continue
                
                # Parse different entry types
                if line.startswith('tap '):
                    # Extract tap name from quotes
                    start = line.find('"') + 1
                    end = line.rfind('"')
                    if start > 0 and end > start:
                        tap_name = line[start:end]
                        result["taps"].append(tap_name)
                
                elif line.startswith('brew '):
                    # Extract package name from quotes
                    start = line.find('"') + 1
                    end = line.rfind('"')
                    if start > 0 and end > start:
                        package_name = line[start:end]
                        result["brew"].append(package_name)
                
                elif line.startswith('cask '):
                    # Extract package name from quotes
                    start = line.find('"') + 1
                    end = line.rfind('"')
                    if start > 0 and end > start:
                        package_name = line[start:end]
                        result["cask"].append(package_name)
        
    except Exception as e:
        logger.error(f"Error parsing Brewfile {brewfile_path}: {e}")
    
    return result
