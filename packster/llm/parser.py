"""Parse Claude AI responses for package migration."""

import json
import re
from typing import Dict, List, Any, Optional
from pathlib import Path


def parse_migration_response(response_text: str) -> Dict[str, Any]:
    """Parse Claude's response and extract structured data.
    
    Args:
        response_text: Raw response from Claude API
        
    Returns:
        Parsed response with installable packages, unavailable packages, and installation script
    """
    
    # Try to extract JSON from the response
    json_match = re.search(r'\{.*\}', response_text, re.DOTALL)
    if not json_match:
        raise ValueError("No valid JSON found in Claude response")
    
    try:
        parsed = json.loads(json_match.group())
    except json.JSONDecodeError as e:
        raise ValueError(f"Invalid JSON in Claude response: {e}")
    
    # Validate required fields
    required_fields = ["installable_packages", "unavailable_packages", "installation_script"]
    for field in required_fields:
        if field not in parsed:
            raise ValueError(f"Missing required field '{field}' in Claude response")
    
    return parsed


def extract_installation_commands(parsed_response: Dict[str, Any]) -> Dict[str, List[str]]:
    """Extract installation commands grouped by method.
    
    Args:
        parsed_response: Parsed response from parse_migration_response
        
    Returns:
        Dictionary with commands grouped by installation method
    """
    
    commands = {
        "homebrew": [],
        "homebrew_cask": [],
        "macports": [],
        "direct": [],
        "builtin": []
    }
    
    for pkg in parsed_response.get("installable_packages", []):
        method = pkg.get("installation_method", "")
        command = pkg.get("command", "")
        
        if method in commands and command:
            # Extract package name from command
            if method == "homebrew" and command.startswith("brew install "):
                package_name = command.replace("brew install ", "").strip()
                commands[method].append(package_name)
            elif method == "homebrew_cask" and command.startswith("brew install --cask "):
                package_name = command.replace("brew install --cask ", "").strip()
                commands[method].append(package_name)
            elif method == "macports" and command.startswith("sudo port install "):
                package_name = command.replace("sudo port install ", "").strip()
                commands[method].append(package_name)
            else:
                # For direct installations, keep the full command
                commands[method].append(command)
    
    return commands


def generate_installation_script(parsed_response: Dict[str, Any]) -> str:
    """Generate a formatted installation script from the parsed response.
    
    Args:
        parsed_response: Parsed response from parse_migration_response
        
    Returns:
        Formatted installation script
    """
    
    # Use the installation script from Claude if available
    if parsed_response.get("installation_script"):
        return parsed_response["installation_script"]
    
    # Fallback: generate our own script
    commands = extract_installation_commands(parsed_response)
    
    script_lines = [
        "#!/bin/bash",
        "",
        "# Generated by Packster with Claude AI",
        "# macOS Package Migration Script",
        "",
        "set -e  # Exit on any error",
        "",
        "echo 'ðŸš€ Starting macOS package migration...'",
        ""
    ]
    
    # Homebrew packages
    if commands["homebrew"]:
        script_lines.extend([
            "echo 'ðŸ“¦ Installing Homebrew packages...'",
        ])
        # Install packages one by one to avoid issues with malformed commands
        for package in commands["homebrew"]:
            if package and package.strip():  # Skip empty packages
                script_lines.append(f"brew install {package}")
        script_lines.append("")
    
    # Homebrew casks
    if commands["homebrew_cask"]:
        script_lines.extend([
            "echo 'ðŸº Installing Homebrew casks...'",
        ])
        # Install casks one by one to avoid issues with malformed commands
        for cask in commands["homebrew_cask"]:
            if cask and cask.strip():  # Skip empty casks
                script_lines.append(f"brew install --cask {cask}")
        script_lines.append("")
    
    # MacPorts packages
    if commands["macports"]:
        script_lines.extend([
            "echo 'âš“ Installing MacPorts packages...'",
        ])
        # Install packages one by one to avoid issues with malformed commands
        for package in commands["macports"]:
            if package and package.strip():  # Skip empty packages
                script_lines.append(f"sudo port install {package}")
        script_lines.append("")
    
    # Direct installations
    if commands["direct"]:
        script_lines.extend([
            "echo 'ðŸ”— Direct installations:'",
        ])
        for cmd in commands["direct"]:
            script_lines.append(cmd)
        script_lines.append("")
    
    # Built-in equivalents
    if commands["builtin"]:
        script_lines.extend([
            "echo 'âœ… Built-in macOS equivalents (no installation needed):'",
        ])
        for note in commands["builtin"]:
            script_lines.append(f"# {note}")
        script_lines.append("")
    
    script_lines.extend([
        "echo 'âœ… Package migration completed!'",
        "echo 'ðŸ“‹ Review the unavailable packages below:'",
        ""
    ])
    
    return "\n".join(script_lines)


def generate_unavailable_report(parsed_response: Dict[str, Any]) -> str:
    """Generate a report of unavailable packages.
    
    Args:
        parsed_response: Parsed response from parse_migration_response
        
    Returns:
        Formatted report of unavailable packages
    """
    
    unavailable = parsed_response.get("unavailable_packages", [])
    if not unavailable:
        return "All packages were successfully mapped to macOS equivalents!"
    
    report_lines = [
        "# Unavailable Packages Report",
        "# These packages could not be migrated to macOS",
        ""
    ]
    
    for pkg in unavailable:
        report_lines.extend([
            f"## {pkg.get('original_name', 'Unknown')}",
            f"**Reason:** {pkg.get('reason', 'No reason provided')}",
        ])
        
        alternatives = pkg.get('alternatives', [])
        if alternatives:
            report_lines.append("**Alternatives:**")
            for alt in alternatives:
                report_lines.append(f"- {alt}")
        
        notes = pkg.get('notes', '')
        if notes:
            report_lines.append(f"**Notes:** {notes}")
        
        report_lines.append("")
    
    return "\n".join(report_lines)


def save_migration_files(
    parsed_response: Dict[str, Any],
    output_dir: Path,
    base_name: str = "llm-migration"
) -> Dict[str, Path]:
    """Save migration files to disk.
    
    Args:
        parsed_response: Parsed response from parse_migration_response
        output_dir: Directory to save files
        base_name: Base name for output files
        
    Returns:
        Dictionary mapping file types to their paths
    """
    
    output_dir.mkdir(parents=True, exist_ok=True)
    
    files = {}
    
    # Installation script
    script_content = generate_installation_script(parsed_response)
    script_path = output_dir / f"{base_name}-install.sh"
    script_path.write_text(script_content)
    script_path.chmod(0o755)  # Make executable
    files["installation_script"] = script_path
    
    # Unavailable packages report
    report_content = generate_unavailable_report(parsed_response)
    report_path = output_dir / f"{base_name}-unavailable.md"
    report_path.write_text(report_content)
    files["unavailable_report"] = report_path
    
    # Full JSON response
    json_path = output_dir / f"{base_name}-response.json"
    json_path.write_text(json.dumps(parsed_response, indent=2))
    files["json_response"] = json_path
    
    return files
